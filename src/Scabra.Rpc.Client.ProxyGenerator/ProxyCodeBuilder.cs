using System;

namespace Scabra.Rpc.Client
{
    internal class ProxyCodeBuilder : CodeBuilder
    {
        public string BuildSourceText(ProxyDescriptor pd)
        {
            AppendAndNormalizeMultipleLines(Autogenerated);

            BuildUsing(pd);
            BreakLine();

            AppendLine($"namespace {pd.NamespaceName}");
            AppendLine("{");
            Indent();

            AppendLine(GeneratedCodeAttribute);
            AppendLine($"partial class {pd.ClassName}");
            AppendLine("{");
            Indent();

            AppendLine("private readonly IScabraRpcChannel _channel;");
            BreakLine();

            AppendLine($"public {pd.ClassName}(IScabraRpcChannel channel)");
            AppendLine("{");
            Indent();

            AppendLine("_channel = channel ?? throw new ArgumentNullException(nameof(channel));");

            Dedent();
            AppendLine("}"); // constructor
            BreakLine();

            for (var i = 0; i < pd.MethodDescriptors.Length; i++)
            {
                BuildMethod(pd.InterfaceName, pd.MethodDescriptors[i]);

                if (i < pd.MethodDescriptors.Length - 1)
                    BreakLine();
            }

            Dedent();
            AppendLine("}"); // class

            Dedent();
            AppendLine("}"); // namespace

            return Build();
        }

        private void BuildUsing(ProxyDescriptor d)
        {
            bool containsSystem = false, containsScabra = false;

            foreach (var @using in d.Usings)
            {
                if (!containsSystem && (@using.Equals("System", StringComparison.Ordinal) || @using.Equals("global::System", StringComparison.Ordinal)))
                    containsSystem = true;
                else if (!containsScabra && @using.Equals("Scabra", StringComparison.Ordinal))
                    containsScabra = true;

                AppendLine($"using {@using};");
            }

            if (!containsSystem)
                AppendLine("using System;");

            if (!containsScabra)
            {
                AppendLine("using Scabra.Rpc;");
                AppendLine("using Scabra.Rpc.Client;");
            }
        }

        private void BuildMethod(string interfaceName, MethodDescriptor d)
        {
            AppendIndented($"public {d.ReturnTypeName} {d.Name}");

            Append("(");

            BuildMethodParameters(d);

            Append(")");
            BreakLine();

            AppendLine("{");
            Indent();
            
            BuildMethodBody(interfaceName, d);

            Dedent();
            AppendLine("}"); // method
        }

        private void BuildMethodParameters(MethodDescriptor d)
        {
            for (var i = 0; i < d.ParameterDescriptors.Length; i++)
            {
                var p = d.ParameterDescriptors[i];

                Append($"{p.TypeName} {p.Name}");

                if (i < d.ParameterDescriptors.Length - 1)
                    Append(", ");
            }
        }

        private void BuildMethodBody(string interfaceName, MethodDescriptor d)
        {
            var isReturnTypeVoid = d.ReturnTypeName == "void";

            if (!isReturnTypeVoid)
                AppendIndented($"var reply = ");
            else
                AppendIndented(string.Empty);

            if (isReturnTypeVoid)
                Append($"_channel.InvokeMethod<{interfaceName}>");
            else
                Append($"_channel.InvokeMethod<{interfaceName}, {d.ReturnTypeName}>");

            Append("(");
            Append($"\"{d.Name}\"");

            for (var i = 0; i < d.ParameterDescriptors.Length; i++)
                Append($", {d.ParameterDescriptors[i].Name}");

            Append(");");

            BreakLine();

            if (!isReturnTypeVoid)
            {
                BreakLine();
                AppendLine($"return reply;");
            }
        }
    }
}
